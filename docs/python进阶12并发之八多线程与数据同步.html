
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>python进阶12并发之八多线程与数据同步 · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 5.1.4">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, user-scalable=yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="python进阶13并发之九多进程和数据共享.html" />
    
    
    <link rel="prev" href="python进阶11并发之七多种并发方式的效率测试.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="python进阶01偏函数.html">
            
                <a href="python进阶01偏函数.html">
            
                    
                    python进阶01偏函数
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="python进阶02yield.html">
            
                <a href="python进阶02yield.html">
            
                    
                    python进阶02yield
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="python进阶03UnboundLocalError和NameError错误.html">
            
                <a href="python进阶03UnboundLocalError和NameError错误.html">
            
                    
                    python进阶03UnboundLocalError和NameError错误
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="python进阶04IO的同步异步,阻塞非阻塞.html">
            
                <a href="python进阶04IO的同步异步,阻塞非阻塞.html">
            
                    
                    python进阶04IO的同步异步,阻塞非阻塞
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="python进阶05并发之一基本概念.html">
            
                <a href="python进阶05并发之一基本概念.html">
            
                    
                    python进阶05并发之一基本概念
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="python进阶06并发之二技术点关键词.html">
            
                <a href="python进阶06并发之二技术点关键词.html">
            
                    
                    python进阶06并发之二技术点关键词
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="python进阶07并发之三其他问题.html">
            
                <a href="python进阶07并发之三其他问题.html">
            
                    
                    python进阶07并发之三其他问题
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="python进阶08并发之四map,apply,map_async,apply_async差异.html">
            
                <a href="python进阶08并发之四map,apply,map_async,apply_async差异.html">
            
                    
                    python进阶08并发之四map,apply,map_async,apply_async差异
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="python进阶09并发之五生产者消费者.html">
            
                <a href="python进阶09并发之五生产者消费者.html">
            
                    
                    python进阶09并发之五生产者消费者
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="python进阶10并发之六并行化改造.html">
            
                <a href="python进阶10并发之六并行化改造.html">
            
                    
                    python进阶10并发之六并行化改造
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="python进阶11并发之七多种并发方式的效率测试.html">
            
                <a href="python进阶11并发之七多种并发方式的效率测试.html">
            
                    
                    python进阶11并发之七多种并发方式的效率测试
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.13" data-path="python进阶12并发之八多线程与数据同步.html">
            
                <a href="python进阶12并发之八多线程与数据同步.html">
            
                    
                    python进阶12并发之八多线程与数据同步
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="python进阶13并发之九多进程和数据共享.html">
            
                <a href="python进阶13并发之九多进程和数据共享.html">
            
                    
                    python进阶13并发之九多进程和数据共享
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="python进阶14变量作用域LEGB.html">
            
                <a href="python进阶14变量作用域LEGB.html">
            
                    
                    python进阶14变量作用域LEGB
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="python进阶15多继承与Mixin.html">
            
                <a href="python进阶15多继承与Mixin.html">
            
                    
                    python进阶15多继承与Mixin
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="python进阶16炫技巧.html">
            
                <a href="python进阶16炫技巧.html">
            
                    
                    python进阶16炫技巧
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.18" data-path="python进阶17正则表达式.html">
            
                <a href="python进阶17正则表达式.html">
            
                    
                    python进阶17正则表达式
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.19" data-path="python进阶18垃圾回收GC.html">
            
                <a href="python进阶18垃圾回收GC.html">
            
                    
                    python进阶18垃圾回收GC
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.20" data-path="python进阶19装饰器和闭包.html">
            
                <a href="python进阶19装饰器和闭包.html">
            
                    
                    python进阶19装饰器和闭包
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.21" data-path="python进阶20之actor.html">
            
                <a href="python进阶20之actor.html">
            
                    
                    python进阶20之actor
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.22" data-path="python进阶21再识单例模式.html">
            
                <a href="python进阶21再识单例模式.html">
            
                    
                    python进阶21再识单例模式
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >python进阶12并发之八多线程与数据同步</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="python进阶12并发之八多线程与数据同步">python进阶12并发之八多线程与数据同步</h1>
<p>python并发<strong>首选进程</strong>，但偶尔有场景进程无法搞定，比如有些<strong>变量是无法序列化的</strong>，就无法使用工具包<strong>manager()的工具类进行共享</strong>。如果自己实现新的共享方法，可能开发量较大，且质量难以保证。此时可考虑用线程处理，规避进程的变量共享难题，而且实际场景中,<strong>IO大概率都是瓶颈</strong>，所以使用线程其实也的确有些优势。个人而言，选择进程和线程较为重视的<strong>安全性</strong>，进程数据隔离较好，互不干扰。其次就是<strong>公用数据占比</strong>，如果大多数数据都需公用，那么线程也会比进程更佳，避免了进程较多的数据共享问题。</p>
<p>线程而言，难点数据一致性，</p>
<h2 id="哪些共享，哪些不共享">哪些共享，哪些不共享</h2>
<p>使用线程，大概率出现的情况，本以为没共享，实际共享了。由于(以为)没共享，所以没做同步处理，导致最后数据一团糟。</p>
<p>参考代码:</p>
<pre><code># coding=utf-8
############## 共享变量均未加锁，仅用来演示共享问题，未考虑同步问题 ###########
############# 线程的变量共享　#############
import threading
import time

gnum = 1


class MyThread(threading.Thread):
    # 重写 构造方法
    def __init__(self, num, num_list, sleepTime):
        threading.Thread.__init__(self)
        self.num = num
        self.sleepTime = sleepTime
        self.num_list = num_list

    def run(self):
        time.sleep(self.sleepTime)
        global gnum
        gnum += self.num
        self.num_list.append(self.num)
        self.num += 1
        print('(global)\tgnum 线程(%s) id:%s num=%d' % (self.name, id(gnum), gnum))
        print('(self)\t\tnum 线程(%s) id:%s num=%d' % (self.name, id(self.num), self.num))
        print('(self.list)\tnum_list 线程(%s) id:%s num=%s' % (self.name, id(self.num_list), self.num_list))


if __name__ == '__main__':
    mutex = threading.Lock()
    num_list = list(range(5))
    t1 = MyThread(100, num_list, 1)
    t1.start()
    t2 = MyThread(200, num_list, 5)
    t2.start()
</code></pre><p>执行结果:</p>
<pre><code>/home/john/anaconda3/bin/python3 /home/john/PYTHON/scripts/concurrent/threadShare.py
(global)    gnum 线程(Thread-1) id:93930593956000 num=101
(self)        num 线程(Thread-1) id:93930593956000 num=101
(self.list)    num_list 线程(Thread-1) id:140598419056328 num=[0, 1, 2, 3, 4, 100]
(global)    gnum 线程(Thread-2) id:140598420111056 num=301
(self)        num 线程(Thread-2) id:93930593959200 num=201
(self.list)    num_list 线程(Thread-2) id:140598419056328 num=[0, 1, 2, 3, 4, 100, 200]
</code></pre><p>结果解析:</p>
<p><img src="./images/20200530222555526_526737758.png" alt=""></img></p>
<h2 id="共享数据的同步参考博文python进阶06并发之二技术点关键词">共享数据的同步(参考博文:python进阶06并发之二技术点关键词)</h2>
<p>最简单做法，凡是会在多个线程中修改的共享对象(变量)，都加锁。这样可能会有部分锁多加了，但绝对好过不加，毕竟多加锁无非导致效率低下(也可能导致死锁)，而一旦该加的没有加，则会导致数据错误，二者孰轻孰重很清楚。建议多了解下"<strong>原子操作</strong>"，如果不熟悉，可以按照<strong>先加锁，再删锁</strong>的思路，将原子操作的锁删掉即可（业务逻辑开发阶段，哪些会在多个线程被修改，是很难想全面的。所以一般是先开发，实现业务逻辑思路，再找共享变量，尽可能缩小临界区间，最后再上锁）。这样一方面保险，另一方面也避免了过多锁带来的低效问题。</p>
<h2 id="thread完整版和简单版的关系">thread完整版和简单版的关系</h2>
<pre><code>class Thread:
    def __init__(self, group=None, target=None, name=None,
                 args=(), kwargs=None, *, daemon=None):
        if kwargs is None:
            kwargs = {}
        self._target = target
        self._name = str(name or _newname())
        self._args = args
        self._kwargs = kwargs

    def run(self):
        try:
            if self._target:
                self._target(*self._args, **self._kwargs)
        finally:
            del self._target, self._args, self._kwargs
</code></pre><h2 id="线程本身就有局部变量，为何还需要threadlocal？">线程本身就有局部变量，为何还需要ThreadLocal？</h2>
<p>ThreadLocal例子</p>
<pre><code>import threading

# 创建全局ThreadLocal对象:
local_school = threading.local()

def process_student():
  print 'Hello, %s (in %s)' % (local_school.student, threading.current_thread().name)

def process_thread(name):
  # 绑定ThreadLocal的student:
  local_school.student = name
  process_student()

t1 = threading.Thread(target= process_thread, args=('Alice',), name='Thread-A')
t2 = threading.Thread(target= process_thread, args=('Bob',), name='Thread-B')
t1.start()
t2.start()
t1.join()
t2.join()
</code></pre><p>网上没有查询到有效资料，说明个人理解吧，</p>
<p>首先，如果你的线程采用了完整模式书写(定义class继承thread)，则的确不需要使用ThreadLocal，其<strong>init</strong>内完全可以定义对象自身的私有变量(list等引用型入参，可通过deepcopy复制出私有的一份).</p>
<p>如果你想采用简洁模式, threading.Thread(target= process_thread, args=xx),那么其实是没有定义私有变量的地方的(也不是完全没有，如果是int,str等，本来就是形参，如果是list()则会共享)</p>
<p>举例：</p>
<pre><code>############# 线程的变量共享(short mode)　#############
gnum = 1


def process(num, num_list, sleepTime):
    time.sleep(sleepTime)
    global gnum
    gnum += num
    num_list.append(num)
    num += 1
    print('(global)\tgnum 线程(%s) id:%s num=%d' % (threading.currentThread().name, id(gnum), gnum))
    print('(self)\t\tnum 线程(%s) id:%s num=%d' % (threading.currentThread().name, id(num), num))
    print('(self.list)\tnum_list 线程(%s) id:%s num=%s' % (threading.currentThread().name, id(num_list), num_list))


if __name__ == '__main__':
    mutex = threading.Lock()
    num_list = list(range(5))
    t1 = threading.Thread(target=process, args=(100, num_list, 1,))
    t1.start()
    t2 = threading.Thread(target=process, args=(200, num_list, 5,))
    t2.start()
</code></pre><p>结果:(和前面相同)</p>
<pre><code>(global)    gnum 线程(Thread-1) id:94051294298272 num=101
(self)        num 线程(Thread-1) id:94051294298272 num=101
(self.list)    num_list 线程(Thread-1) id:140412783240456 num=[0, 1, 2, 3, 4, 100]
(global)    gnum 线程(Thread-2) id:140412784295536 num=301
(self)        num 线程(Thread-2) id:94051294301472 num=201
(self.list)    num_list 线程(Thread-2) id:140412783240456 num=[0, 1, 2, 3, 4, 100, 200]
</code></pre><p>可见，对于单个函数的线程，其实没必要使用threadLocal</p>
<p>那么那种情况需要使用呢？</p>
<pre><code>global_dict = {}

def std_thread(name):
    std = Student(name)
    # 把std放到全局变量global_dict中：
    global_dict[threading.current_thread()] = std
    do_task_1()
    do_task_2()

def do_task_1():
    # 不传入std，而是根据当前线程查找：
    std = global_dict[threading.current_thread()]
    ...

def do_task_2():
    # 任何函数都可以查找出当前线程的std变量：
    std = global_dict[threading.current_thread()]
    ...
</code></pre><p>对于存在调用子函数，且函数之间存在参数传递的情况才需要使用threadLocal</p>
<p>同时，如果本身thread使用的就是完整模式的thread了，那么由于本身的self.xx已经是局部变量了，所以也不需要使用threadLocal进行中转保存.</p>
<p>综上所述，其实threadLocal的使用场景是比较有限的，必须是thread简洁模式下，存在函数调用和传参的情况下在有必要使用。</p>
<h2 id="类锁还是实例锁">类锁还是实例锁?</h2>
<p>由于锁和临界区是对应的（作为临界变量，临界区的保镖），如果临界变量（区)是类级别信息（比如统计类实例个数），就用类锁，否则就是实例锁。</p>
<h2 id="阻塞式io中，cpu分配时间片给阻塞线程么">阻塞式io中，cpu分配时间片给阻塞线程么</h2>
<p>运行态---wait/阻塞io-→阻塞态</p>
<p>运行态-------调度--------→就绪态</p>
<p>就绪态-------调度--------→运行态</p>
<p>阻塞态---信号/io返回-→就绪态</p>
<p>所以不占用时间片。</p>
<p>sleep（）和wait()这两个函数被调用之后线程都应该放弃执行权，不同的是sleep（）不释放锁而wait（）的话是释放锁。直白的意思是一个线程调用Sleep（）之后进入了阻塞状态中的其他阻塞，它的意思就是当sleep()状态超时、join()等待线程终止或者超时，线程重新转入可运行(runnable)状态。而Wait（）是不同的在释放执行权之后wait也把锁释放了进入了线程等待阻塞，它要运行的话还是要和其他的线程去竞争锁，之后才可以获得执行权。</p>
<h2 id="多线程中target为实例方法可访问哪些变量的测试">多线程中,target为实例方法,可访问哪些变量的测试</h2>
<p>举例：</p>
<p><img src="./images/20200622225859715_117416988.png" alt=""></img></p>
<p>get_face_result中可以访问self里面的哪些资源？在1处（thread声明后，start前）和2处（start后）定义的变量可以访问么？</p>
<p>主要疑惑：target=get_face_result，如果get_face_result看作普通函数，那么由于不存在全局变量，所以所有参数都应该从args传入,</p>
<p>问题就是在get_face_result不是普通函数，不确定python是否会把self.里的变量传递到get_face_result内部（也就是self.里的实例变量看作 self.get_face_result的全局变量）</p>
<p>结论：<strong>以thraed.start为界，start之前一定可以访问</strong>，start之后是否可以访问，视主线程和子线程执行速度，可能可以，可能不行</p>
<p>所以：<strong>1处的代码，子线程可以访问</strong>，<strong>2处的代码</strong>，由子线程执行速度（访问2处赋值的变量的时间），和父线程<strong>执行速度决定</strong>，如果父线程速度快，那么2处的（子线程）也可以访问，否则，（子线程）无法访问。</p>
<p>测试步骤</p>
<p>测试01:如上图</p>
<p>结果：</p>
<pre><code>1
2
</code></pre><p>结论：start后变量，如果有足够时间差，子线程就可以访问</p>
<p>测试02：</p>
<p><img src="./images/20200622230118395_547243016.png" alt=""></img></p>
<p><img src="./images/20200622230131517_5907947.png" alt=""></img></p>
<p>结论：start后变量，没有足够时间差，子线程无法访问</p>
<p>测试04：引用型变量会如何</p>
<p><img src="./images/20200622230219047_107149376.png" alt=""></img></p>
<p><img src="./images/20200622230231442_523146462.png" alt=""></img></p>
<p><img src="./images/20200622230245764_1299518672.png" alt=""></img></p>
<p><img src="./images/20200622230255708_2089305957.png" alt=""></img></p>
<p>结论不变，start后，父线程子线程先后顺序影响了变量赋值</p>
<h2 id="condition和event">Condition和Event</h2>
<p>参考：</p>
<p>Python多线程—线程同步（<strong>Lock/RLock、Condition、queue、Event</strong>）：<a href="https://blog.csdn.net/Lesour/article/details/88808139" target="_blank">https://blog.csdn.net/Lesour/article/details/88808139</a></p>
<h2 id="参考">参考</h2>
<p><a href="https://blog.csdn.net/u010660276/article/details/50574180" target="_blank">python ThreadLocal</a></p>
<p><a href="https://www.jianshu.com/p/74640d22a72f" target="_blank">深入理解Python中的ThreadLocal变量（上）</a></p>
<p><a href="https://www.cnblogs.com/linpd/p/10051945.html" target="_blank">Python中ThreadLocal的理解与使用</a></p>
<p><a href="https://www.jianshu.com/p/c655e0a944ae" target="_blank">在阻塞式io中，如果一个线程在等待io操作，那么cpu还会分配时间片给该线程吗？</a></p>
<p>Python多线程—线程同步（<strong>Lock/RLock、Condition、queue、Event</strong>）：<a href="https://blog.csdn.net/Lesour/article/details/88808139" target="_blank">https://blog.csdn.net/Lesour/article/details/88808139</a></p>
<p>python笔记11-多线程之Condition（条件变量）(<strong>notify,wait锁传递，细节控制</strong>):<a href="https://www.cnblogs.com/yoyoketang/p/8337118.html" target="_blank">https://www.cnblogs.com/yoyoketang/p/8337118.html</a></p>
<p>python3是如何使用线程的（Event与Condition）(<strong>在python cookbook中建议event作为一次性事件使用,Condition可以进行多次通知，并通知不同数量的线程</strong>):<a href="https://blog.csdn.net/qq_34392457/article/details/108319357" target="_blank">https://blog.csdn.net/qq_34392457/article/details/108319357</a></p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="python进阶11并发之七多种并发方式的效率测试.html" class="navigation navigation-prev " aria-label="Previous page: python进阶11并发之七多种并发方式的效率测试">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="python进阶13并发之九多进程和数据共享.html" class="navigation navigation-next " aria-label="Next page: python进阶13并发之九多进程和数据共享">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"python进阶12并发之八多线程与数据同步","level":"1.13","depth":1,"next":{"title":"python进阶13并发之九多进程和数据共享","level":"1.14","depth":1,"path":"python进阶13并发之九多进程和数据共享.md","ref":"python进阶13并发之九多进程和数据共享.md","articles":[]},"previous":{"title":"python进阶11并发之七多种并发方式的效率测试","level":"1.12","depth":1,"path":"python进阶11并发之七多种并发方式的效率测试.md","ref":"python进阶11并发之七多种并发方式的效率测试.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"python进阶12并发之八多线程与数据同步.md","mtime":"2024-08-26T14:40:59.564Z","type":"markdown"},"gitbook":{"version":"5.1.4","time":"2024-08-26T14:56:56.347Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

